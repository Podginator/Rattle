// Test multiple inheritance. Hello Extends Test extends First Test
class firstTest {
    def printGoodbye() {
        print "Can you save my heavydirtysoul?"
    }
}

// Test multiple inheritance
class test extends firstTest {
	testing = "testoutter"
	// Tests whether we can have two indepent references in classes
	// With the same name (We shouldn't be able to, super->counter == this->counter)
	counter = 0

    // Test when a method is only available in
	def decrementAndGetCounter() {
	    // Tests stacking inside a method
        def decrementCounter() {
            return counter - 1
        }

        // tests writing out to a variable
        this->counter = decrementCounter()
        return counter
    }

    def operateOnCounter(x, y) {
        return x(this->counter) + y
    }

    // Add Two Numbers, one of which is named the same as
    // a member. This tests that we can effectively distinguish
    // between the two variables.
    def addNumbers(a, counter) {
        return a + counter
    }

    // Increment a counter by 20, overriden in hello
    // to be one.
    def incrementAndGetCounter() {
        counter = counter + 20
        return counter
    }

    // This prints something different than super->printGoodbye
    def printGoodbye() {
        print "Goodbye"
    }
}

class hello extends test {
    // Tests that we can effectively
    // define classes in classes.
	class testInnerTwo {
		name = "innertwo"
		test = {create test}
	}

	class testInnerClass {
		name = "TestInner"
	}

	name = "TR"
	date = "20/12/92"
	counter = 0
	inner = {create testInnerClass}

	class Two {
		name = "TestInner"
	}

	def getInnerClassValue() {
		return inner->name
	}

	def getOutterClassValue() {
		x = {create test}
		return x->testing
	}

	def incrementAndGetCounter() {
		def incrementCounter() {
			return counter + 1
		}
		counter = incrementCounter()

		return counter
	}

	def doOriginalIncrement() {
	    counter = super->incrementAndGetCounter()
	    return counter
	}

	def printGoodbye() {
	    print "Top Layer Goodbye!"
	}

	def printHelloaa(c) {
	    return c
	}
}

i = 7
i = {create hello where name="ey!"}

print i->name

// This simple lambda returns two things, so to get both values from it we'd have to say a,b =
simpleLambda = (x,y) -> { return y + x, x / y }
a,b = simpleLambda(1,2)
print "return 1 of simpleLambda: " + a
print "return 2 of simple Lambda: " + b

// This just proves we can do this without functions
c, d, e, f = 12, "T",  "O", "M"
print "c = " + c
print "d = " + d
print "e = " + e
print "f = " + f

// This just proves we can do this with member variables
i->name, i->inner->name = d, e
print "i->name = " + i->name
print "i->inner->name = " + i->inner->name

lambdaA = (x)->{ return x * 4 }
lambdaB = (x)->{ return x * 8 }
lambdaC = (x)->{ return x * 16 }
lambdaD = lambdaA + lambdaB + lambdaC

i->incrementAndGetCounter()
print "i->operateOnCounter(x,y) where x =  lambda curried to do x * 4 * 8 * 16, counter = 1 and y = 0.  So 512 : "
            + i->operateOnCounter(lambdaD, 0)


multiLambdaA = (x,y)->{return x * 2, y /2 }
multiLambdaB = (x,y)->{return x * 4, y / 4 }
multiLambdaD = multiLambdaA + multiLambdaB

resultA, resultB = multiLambdaD(1,2)
print resultA
print multiLambdaD(1,3)[1]
